<h1>答辩Q&A整理</h1>

2020年9月8日 淘兴趣第一场 18：00-18：20

<h2> 答辩现场问题</h2>

Q1. 你们security用的是jwt嘛，jwt的expiration是怎么解决的？就是jwt它实际上会有过期的时间嘛，那你们是怎么处理这个，比如说已经过期之后再重新访问这些东西。

A1. 是这样，我们后端在接收前端这个请求的时候，不是每个接口都放一个jwt函数，就是放一个拦截器进行，如果他的时间已经过期了，那么解析的时候就会有问题，就不能通过拦截器到达下一个接口。

Q2. 有问题最后呢？后面的反应呢？比如说设个1天，但是登陆过后1天就被禁止了。

A2. 这个就相当于它访问不了了。确实前端没有做出相应的反应。

Q3. 既然你们提到了用户搜索，我想知道你们的搜索是怎么实现的？

A3. 搜索是在数据库里面建了一个关于用户名字的索引，到时候可以采用模糊搜索的方式，根据用户的名字或者是手机号。

Q4. 推荐算法你们只列出了几种使用的matrix，那么这几种算法是怎么（实现的）？

A4. 就是他不是有一个兴趣还有一个热度嘛，当我们每拿到一个key值的时候，就是从数据库拿到一些blog的时候，有标签。因为我们会先把用户拿出来，然后从用户肖像中他比较感兴趣的几个标签，最后我们遍历这几个博客的时候如果占有了他最感兴趣的几个标签，或者说这个blog是他关注的人发送的或者说这个blog的热度（根据我们现在这个情况，是比较高的点赞或者收藏，如果他高于一定数值的时候我们会认为它是一个比较热门的blog））就返回这些blog。

Q5. 所以这就相当于博客点赞和收藏转发达到一定阈值的时候，你就会认为他是比较（符合条件的）？

A5. 他就符合热门的条件，然后其他会有符合感兴趣条件或者关注的人发的条件。

Q6. 这三个是同样权重的吗？

A6. 我们目前是同样权重的。因为我们是拿出一部分，如果他们满足这三个中的一个就认为可以返回。

Q7. 那还是有一个顺序吧？

A7. 对，先检查兴趣，然后检查关注，然后是之前的热度。

Q8. 你们用了mysql和mongodb，那么会有一个操作既往Mongodb中存，也要往mysql里面存。你们怎么处理这个事务？大概说一下，比如说用户创建了一个新的博客。

A8. 比如说他发了一个新的博客，首先我们会先保存mysql，因为保存之后JPA才会给他生成对应的id，然后生成对应的id之后，我们用这个id把mongo也储存了。

Q9. 那如果Mongo服务器损坏呢？就是假设你mysql存完之后服务器挂了呢，你怎么保证这两个storage的consistency？

A9. 这个情况，mongo存储失败之后服务会停掉。这个我们虽然没做，但是两个数据库是注册方面的，用户登陆的时候如果检查到mongodb里面没有，那么这个就会返回一个错误。

Q10. 另外那个cache你们说用缓冲区，那个缓冲区怎么实现的？

A10. 就是比如说我们发现用户常用的getpublicblogs，很多用户在登陆之前也要看这个东西，登录之后也要看这个，然后我们就在这个函数里面设置一个缓冲区。然后再比如说别人点赞，如果我们发现点赞或者转发这个博客是在我们的缓冲区里的，我们会把对应的缓冲区里刷新一下。

Q11. 你们不是用的mongo 吗，springboot 都帮你们搞定了。

A11. 他也不算完全搞定吧。

Q12. 用户少，一大堆人，每个人都访问一次。如果很多人那个blog一直在用的话不是一直在刷新吗？那这个缓冲区也要一直在刷新。

A12. 我们没有在大部分的接口上设置，像我们实际测试的这种共有的这种博客，任何人登录都要访问的这个，这种接口我们认为他是特别常用的。

Q13. 但是你这个不是应该登陆上来刷新的是他关注的东西吗？

A13. 没有登陆的时候是公有的博客，登录之后是自己感兴趣的东西。

Q14. 点赞数你们是怎么实现的？是他每点赞一次就往数据库里面写一次吗？你不会觉得并发量很大的时候这样操作一次写一次对数据库的压力很大吗？

A14. 对的。我们前端有做这个，他点赞我们会把点赞请求发过去，然后看情况会直接给他+1。

Q15. 问题是你这样不停的操作会对数据库的负担加大，然后在高并发的情况下可能会卡住。

A15. 当时我们有考虑做这个计数器，但是时间有点紧。